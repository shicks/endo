use std::cell::Cell;
use std::ptr;

fn main() {
  let r = rope("IICIFPIFCPCIFP");
  println!("{}", rope_str(&r));
}

const THRESHOLD: usize = 500;

#[repr(u8)]
#[derive(Clone,Copy)]
enum Base {
  I = 0,
  C = 1,
  F = 2,
  P = 3,
}

#[derive(Clone)]
enum Node {
  App(App),
  Leaf(Vec<Base>),
}

#[derive(Clone)]
struct App {
  // Note: these are ~always present, except during rebalancing.
  left: Option<Box<Node>>,
  right: Option<Box<Node>>,
  length: usize,
  depth: i8,
}


struct Rope {
  node: Node,
  fingerIndex: Cell<usize>,
  // NOTE: Use a raw pointer because we have no way to
  // tie this lifetime to a borrow from inside the node.
  // We must MANUALLY maintain the invariant that any time
  // we mutate the node, we zero the finger.
  fingerLeaf: Cell<*const Vec<Base>>,
}

impl App {
  #[inline]
  fn take_children(&mut self) -> (Box<Node>, Box<Node>) {
    (self.left.take().unwrap(), self.right.take().unwrap())
  }
}

impl Node {
  fn dep(&self) -> i8 {
    match self {
      Node::App(App{depth, ..}) => *depth,
      Node::Leaf(..) => 0,
    }
  }

  fn len(&self) -> usize {
    match self {
      Node::App(App{length, ..}) => *length,
      Node::Leaf(arr) => arr.len(),
    }
  }

  fn at(&self, index: usize, orig: usize, parent: &Rope) -> Base {
    match self {
      Node::App(App{left, right, ..}) => {
        let l = left.len();
        if index < left.len() {
          left.at(index, orig, parent)
        } else {
          right.at(index - l, orig, parent)
        }
      },
      Node::Leaf(arr) => {
        // TODO - range checking?
        parent.fingerIndex.set(orig - index);
        parent.fingerLeaf.set(&*arr);
        arr[index]
      }
    }     
  }

  #[inline]
  fn unwrap_app(&self) -> &App {
    match self {
      Node::App(a) => a,
      _ => panic!("Expected an App"),
    }
  }

  // #[inline]
  // fn unwrap_app(&mut self) -> &mut App {
  //   match self {
  //     Node::App(a) => a,
  //     default => panic!("Expected an App"),
  //   }
  // }

  #[inline]
  fn take_children(&mut self) -> (Box<Node>, Box<Node>) {
    match self {
      Node::App(ref mut a) => a.take_children(),
      _ => panic!("Expected an App"),
    }
  }

  fn rebalance(&mut self) {
    // Here's where things get real.
    // Should we move this into join?  We want to be able to
    // do a simple rebalancing after splicing in/out data.
    // Moving to join would make it more of a persistent deal?
    // Maybe we need to write splice?
    match self {
      Node::Leaf(..) => { return; }
      Node::App(ref mut app) => {
        let dl = app.left.unwrap().dep();
        let dr = app.right.unwrap().dep();
        if (dl - dr).abs() <= 1 { return; }
        if dl > dr { // taller left
          let (mut l, r) = app.take_children();
          let (ll, mut lr) = l.take_children();
          if lr.dep() > ll.dep() { // tall middle
            let (lrl, lrr) = lr.take_children();
            app.left = Node::join(ll, lrl));
            app.right = Box::new(Node::join(lrr, r));
          } else { // left-skewed: simple rotate
            app.left = Box::new(ll);
            app.right = Box::new(Node::join(lr, r));
          }
        } else { // taller right

        }
      }
    }
  }

  fn join(_left: Node, _right: Node) -> Node {
    panic!("not implemented");
  }
}


impl Rope {
  #[inline]
  pub fn len(&self) -> usize {
    self.node.len()
  }

  // Range check and -> Option<Base> ?
  pub fn at(&self, index: usize) -> Base {
    let leaf = self.fingerLeaf.get();
    if !leaf.is_null() {
      let finger = self.fingerIndex.get();
      unsafe {
        if index >= finger && index < finger + (*leaf).len() {
          return (*leaf)[index - finger];
        }
      }
    }
    self.node.at(index, index, self)
  }
}

  // fn balance(&self) -> Rope {
  //   match self {
  //     Rope::Leaf(..) => self.clone(),
  //     Rope::App{left, right, ..} => {
  //       let dl = left.dep();
  //       let dr = right.dep();
  //       if (dl - dr).abs() <= 1 {
  //         return self.clone();
  //       }
  //       if dl > dr {
  //         // left taller
  //         let ll = left.unsafe_left();
  //         let lr = left.unsafe_right();
  //         if lr.dep() > ll.dep() {
  //           // Need to figure out ownership here...!
  //           join(join(ll, lr.unsafe_left()),
  //                join(lr.unsafe_right(), right))
  //         } else {
  //           join(ll, join(lr, right))
  //         }
  //       } else {
  //         // right taller
  //         let rl = right.unsafe_left();
  //         let rr = right.unsafe_right();
  //         if rl.dep() > rr.dep() {
  //           join(join(left, rl.unsafe_left()),
  //                join(rl.unsafe_right(), rr))
  //         } else {
  //           join(join(left, rl), rr)
  //         }
  //       }
  //     }
  //     Rope::Top(rope, i, l) => panic!("top inside balance")
  //   }
  // }

  // fn toLeaf(&self) -> Rope {
  //   match self {
  //     Rope::Leaf(a) => self,
  //     Rope::Top(rope, ..) => rope.toLeaf(),
  //     Rope::App(left, right, ..) => {
  //       let l = left.len();
  //       let r = right.len();
  //       let mut buf = Vec::with_capacity(l + r);
  //       let mut stack: Vec<&Rope> = Vec::new();
  //       let mut index: usize = 0;
  //       stack.push(right);
  //       stack.push(left);
  //       while stack.len() > 0 {
  //         match stack.pop().unwrap() {
  //           Rope::Top(rope) => {
  //             stack.push(rope);
  //           }
  //           Rope::Leaf(arr) => {
  //             let a = arr.len();
  //             buf[index .. index + l].copy_from_slice(arr);
  //             index += l;
  //           }
  //           Rope::App{left, right, ..} => {
  //             stack.push(&*right);
  //             stack.push(&*left);
  //           }
  //         }
  //       }
  //       Rope::Leaf(buf.into())
  //     }
  //   }
  // }

// impl Copy for Rope {
//     #[inline]
//     fn copy(&self) -> Rope {
//         match self {
//             Rope::Leaf(arr) => Rope::Leaf(arr.clone()),
//             Rope::App({left, right, length, depth}) =>
//                 Rope::App({left: left.clone(), right: right.clone(), length, depth}),
//         }
//     }
// }



// fn join(mut left: &Rope, mut right: &Rope) -> Rope {
//   let l = left.len();
//   let r = right.len();
//   if l == 0 { return right.clone(); }
//   if r == 0 { return left.clone(); }
//   if l + r < THRESHOLD {
//   }
//   // TODO - balance height
//   let mut dl = left.dep();
//   let mut dr = right.dep();
//   while dl - dr > 1 || dr - dl > 1 {
//     if dl > dr {
//       let ll = left.unsafe_left();
//       let lr = left.unsafe_right();
//       if lr.dep() > ll.dep() {
//         // Problem - left/right want refs... who owns lifetime?
//         left = join(ll, lr.unsafe_left());
//         dl = left.dep();
//         right = join(lr.unsafe_right(), right);
//         dr = right.dep();
//       } else {
//         dl = (left = ll).dep();
//         dr = (right = join(lr, right)).dep();
//       }
//     } else {
//       panic!();
      
//     }

//   }
//   panic!();
// }

fn rope(s: &str) -> Rope {
  let mut vec = Vec::new();
  for c in s.chars() {
    vec.push(match c {
      'I' => Base::I,
      'C' => Base::C,
      'F' => Base::F,
      'P' => Base::P,
      _ => Base::I, // panic?
    })
  }
  //let slice: [Base] = &vec;
  Rope{node: Node::Leaf(vec.into()),
       fingerIndex: Cell::new(0),
       fingerLeaf: Cell::new(ptr::null())}
}

fn rope_str(r: &Rope) -> String {
  let mut buf = String::with_capacity(r.len());
  let mut stack: Vec<&Node> = vec![&r.node];
  while stack.len() > 0 {
    match stack.pop().unwrap() {
      Node::Leaf(arr) => {
        for base in arr.iter() {
          match base {
            Base::I => buf.push('I'),
            Base::C => buf.push('C'),
            Base::F => buf.push('F'),
            Base::P => buf.push('P'),
          }
        }
      }
      Node::App(App{left, right, ..}) => {
        stack.push(&right);
        stack.push(&left);
      }
    }
  }
  buf
}
